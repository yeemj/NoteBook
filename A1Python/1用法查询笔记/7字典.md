字典是Python中唯一内建的映射类型。字典中没有特殊的顺序，都存储在一个特定的键下面，键可以是数字，字符串，甚至是元组。

#### 1. 定义

~~~python
#键值对
#方法一：{key: value}
dic1 = {'A':95,'B':98,'C':96}
print(dic1)
#》》{'A': 95, 'B': 98, 'C': 96}

#方法二：字典推导
list1 = ['A','B','C']
list2 = [95,98,96]
dic2 = {list1[i] : list2[i] for i in range(len(list1))}
print(dic2)
#》》{'A': 95, 'B': 98, 'C': 96}

~~~

- 要点：

  - 键具有唯一性，值可以重复

    ~~~python
    dic1 = {'A':95,'B':98,'C':96,'D':98}
    dic2 = {'A':95,'B':98,'C':96,'A':98}
    print(dic2) 
    #》》{'A': 98, 'B': 98, 'C': 96}     #在后面重新定义了A的值
    ~~~

    

#### 2. 提取值

字典名[键]——取得字典的值

~~~python
dic1 = {'A':95,'B':98,'C':96}
print(dic1['A'])
#》》95
~~~



#### 3. 字典的修改

- 删除键值对

  `del 字典名[键]`

  ~~~python
  dic1 = {'A':95,'B':98,'C':96,'D':98}
  del dic1['B']
  print(dic1)
  #》》{'A': 95, 'C': 96, 'D': 98}
  ~~~

  

- 新增键值对

  `字典名[键] = 值`

  ~~~python
  dic1 = {'A':95,'B':98,'C':96,'D':98}
  dic1['E'] = 100
  print(dic1)
  #》》{'A': 95, 'B': 98, 'C': 96, 'D': 98, 'E': 100}
  ~~~

  

- 直接修改某值

  `字典名[键] = 值`

  ~~~python
  dic1 = {'A':95,'B':98,'C':96,'D':98}
  dic1['A'] = 100
  print(dic1)
  #》》{'A': 100, 'B': 98, 'C': 96, 'D': 98}
  ~~~

- 判断字典是否存在指定的key

  `key in 字典`

  ~~~python
  dic1 = {'A':95,'B':98,'C':96,'D':98}
  print('A' in dic1)
  #》》True
  print('E' in dic1)
  #》》False
  ~~~

  

#### 4. 字典的函数

- `clear`

  得到一个空字典

  ~~~python
  dic1 = {'A':95,'B':98,'C':96,'D':98}
  dic1.clear()
  print(dic1)
  #》》{}
  ~~~

  

- `copy`

  与列表的`copy`方法进行比较。

  ~~~python
  import copy
  dic1 = {'A': 90, 'B': [91, 92, 93], 'C': 94}    #  原字典
  dic2 = dic1                         # 直接赋值
  dic3 = dic1.copy()                  # 浅拷贝，只深拷贝父级目录
  dic4 = copy.deepcopy(dic1)          # 深拷贝拷贝，父级目录，子级目录全部拷贝（需导入copy模块）
  
  #修改dic1
  dic1['A'] = 100
  dic1['B'][2] = 94
  print(dic1)   #》》{'A': 100, 'B': [91, 92, 94], 'C': 94}   
  print(dic2)   #》》{'A': 100, 'B': [91, 92, 94], 'C': 94}  #直接赋值，父子级都改变
  print(dic3)   #》》{'A': 90, 'B': [91, 92, 94], 'C': 94}  #浅拷贝，改变子级
  print(dic4)   #》》{'A': 90, 'B': [91, 92, 93], 'C': 94}  #深拷贝，都不改变
  
  #修改赋值字典（均在原始的基础上更改）
  dic2['C'] = 95
  dic2['B'][1] = 93
  print(dic1)  #》》{'A': 90, 'B': [91, 93, 93], 'C': 95}
  print(dic2)  #》》{'A': 90, 'B': [91, 93, 93], 'C': 95}
  print(dic3)  #》》{'A': 90, 'B': [91, 93, 93], 'C': 94}
  print(dic4)  #》》{'A': 90, 'B': [91, 92, 93], 'C': 94}
  ###修改赋值字典，导致原字典改动完全一致
  ###浅拷贝，copy，改变子级
  ###深拷贝，deepcopy，都不影响
  
  #修改copy字典（均在原始的基础上更改）
  dic3['C'] = 100
  dic3['B'][0] = 90
  print(dic1)  #》》{'A': 90, 'B': [90, 92, 93], 'C': 94}
  print(dic2)  #》》{'A': 90, 'B': [90, 92, 93], 'C': 94}
  print(dic3)  #》》{'A': 90, 'B': [90, 92, 93], 'C': 100}
  print(dic4)  #》》{'A': 90, 'B': [91, 92, 93], 'C': 94}
  ###修改浅拷贝字典，也会更改原字典的子级
  
  #修改deepcopy字典（在原始的基础上更改）
  dic4['A'] = 100
  dic3['B'][0] = 90
  print(dic1)  #》》{'A': 90, 'B': [90, 92, 93], 'C': 94}
  print(dic2)  #》》{'A': 90, 'B': [90, 92, 93], 'C': 94}
  print(dic3)  #》》{'A': 90, 'B': [90, 92, 93], 'C': 94}
  print(dic4)  #》》{'A': 100, 'B': [91, 92, 93], 'C': 94}
  
  ~~~

  - 直接赋值：新旧字典同步更改

  - 浅拷贝`copy`，新旧字典子级完全一致，父级没有关系

  - 深拷贝`deepcopy`新旧字典没有任何关系

    

- `fromkeys`

  给定的多个 key 创建字典。这key 对应的 value 默认都是 None；也可额外传入一个参数作为默认的 value。

  一般不会使用字典对象调用，通常会使用 `dict` 类直接调用。

  ~~~python
  dic1 = dict.fromkeys(['a','b','c'])
  print(dic1)
  #》》{'a': None, 'b': None, 'c': None}
  
  dic2 = dict.fromkeys((11,22,33))
  print(dic2)
  #》》{11: None, 22: None, 33: None}
  
  dic3 = dict.fromkeys(['a','b','c'],111)
  print(dic3)
  #》》{'a': 111, 'b': 111, 'c': 111}
  
  dic4 = dict.fromkeys(['a','b','c'],(11,22,33))
  print(dic4)
  #》》{'a': (11, 22, 33), 'b': (11, 22, 33), 'c': (11, 22, 33)}
  ~~~

  

  

- `get`

  根据key来获取value。

  虽然可以通过`字典名[键]`来获得值，但如果不存在要访问的key，程序会报`keyError`错误。但是用`get()`方法访问不存在的key，方法会返回`None`

  ~~~python
  dic1 = {'A':95,'B':98,'C':96,'D':98}
  print(dic1.get('D'))
  #》》98
  print(dic1.get('E'))
  #》》None
  print(dic1['E'])
  #》》KeyError: 'E'
  ~~~

  

- `items`

  获取字典所有的键值对。

  返回类型是：dic_items。可以用list()方法转化成列表

  ~~~python
  dic1 = {'A':95,'B':98,'C':96,'D':98}
  ims1 = dic1.items()
  print(type(ims1))  #查看数据类型
  #》》<class 'dict_items'>
  
  list1 = list(ims1)
  print(list1)  #转化成列表类型
  #》》[('A', 95), ('B', 98), ('C', 96), ('D', 98)]
  
  print(list1[0])  #查看列表的第一个元素
  #》》('A', 95)
  ~~~

  

- `keys`

  获取字典所有的键。

  返回类型是：dic_keys。可以用list()方法转化成列表

  ~~~python
  dic1 = {'A':95,'B':98,'C':96,'D':98}
  key1 = dic1.keys()
  print(type(key1))  #查看数据类型
  #》》<class 'dict_keys'>
  
  list1 = list(key1)
  print(list1)  #转化成列表类型
  #》》['A', 'B', 'C', 'D']
  
  print(list1[1])  #查看列表的第一个元素
  #》》B
  ~~~

  

- `values`

  获取字典所有的值。

  返回类型是：dic_values。可以用list()方法转化成列表

  ~~~python
  dic1 = {'A':95,'B':98,'C':96,'D':98}
  value1 = dic1.values()
  print(type(value1))  #查看数据类型
  #》》<class 'dict_values'>
  
  list1 = list(value1)
  print(list1)  #转化成列表类型
  #》》[95, 98, 96, 98]
  
  print(list1[2])  #查看列表的第一个元素
  #》》96
  ~~~

  

- `pop`

  获取指定的key对应的value，并且删除这个键值对

  ~~~python
  dic1 = {'A':95,'B':98,'C':96,'D':98}
  print(dic1.pop('A'))
  #》》95
  
  print(dic1)
  #》》{'B': 98, 'C': 96, 'D': 98}
  ~~~

  

- `popitem`

  删除最后插入的键值对

  ~~~python
  dic1 = {'A':95,'B':98,'C':96,'D':98}
  print(dic1.popitem())
  #》》('D', 98)
  print(dic1)
  #》》{'A': 95, 'B': 98, 'C': 96}
  ~~~

  

- `setdefault`

  返回指定键的值（有`get`方法）。

  如果该键不存在，则插入具有指定值（默认值）的键。

  ~~~python
  dic1 = {'A':95,'B':98,'C':96,'D':98}
  print(dic1.setdefault('C'))
  #》》96
  
  print(dic1.setdefault('E'))  #不存在的‘E’的值，插入指定值（None）并且返回None
  #》》None
  print(dic1)
  #》》{'A': 95, 'B': 98, 'C': 96, 'D': 98, 'E': None}
  
  print(dic1.setdefault('F',99))  #不存在的'F'的值，插入给定值'99'，并且返回给定值‘99’
  #》》99
  print(dic1)
  #》》{'A': 95, 'B': 98, 'C': 96, 'D': 98, 'E': None, 'F': 99}
  
  print(dic1.setdefault('A',59))  #存在的'A'的值，给定了值59，不会改变
  #》》95
  print(dic1)
  #》》{'A': 95, 'B': 98, 'C': 96, 'D': 98, 'E': None, 'F': 99}
  ~~~

  

- `update`

  更新原来有的字典。

  如果原来的键值对有，就更新。如果没有，就添加。

  ~~~python
  dic1 = {'A':95,'B':98,'C':96,'D':98}
  dic1.update({'A':98,'E':100})
  print(dic1)
  #》》{'A': 98, 'B': 98, 'C': 96, 'D': 98, 'E': 100}
  ~~~

  

  



